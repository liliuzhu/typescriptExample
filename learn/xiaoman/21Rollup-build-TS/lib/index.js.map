{"version":3,"file":"index.js","sources":["../src/index.ts"],"sourcesContent":["/*\n* 配置rollup\n* */\n\n// import * as process from \"process\";\n//\n// const a:string = 'xiao2313423365666767'\n// console.log(a)\n// console.log(process.env.NODE_ENV)\n// if(process.env.NODE_ENV === 'development'){\n//     console.log('开发')\n// }else {\n//     console.log('生产')\n// }\n\n\n/*\n* ts实现发布订阅\n* */\ninterface Events {\n    on: (name:string,fn:Function) => void,\n    emit: (name:string, ...args:Array<any>) => void,\n    off: (name:string,fn:Function) => void,\n    once: (name:string,fn:Function) => void,\n}\n\ninterface List {\n    [key:string]: Array<Function>\n}\n\nexport class Dispatch implements Events {\n    list:List\n    constructor() {\n        this.list = {}\n    }\n    on(name:string,fn:Function){\n        const callbacks = this.list[name] || []\n        callbacks.push(fn)\n        this.list[name] = callbacks\n    }\n    emit(name:string, ...args:Array<any>){\n        let eventName = this.list[name]\n        if(eventName){\n            eventName.forEach(fn=>{\n                fn(...args)\n            })\n        }\n    }\n    off(name: string, fn:Function){\n        let eventName = this.list[name]\n        if(eventName && fn){\n            let index = eventName.findIndex(fns => fns === fn)\n            eventName.splice(index, 1)\n        }\n    }\n    once(name:string,fn:Function){\n        let de = (...args: Array<any>)=>{\n            fn(...args)\n            this.off(name, de)\n        }\n\n        this.on(name, de)\n    }\n}\n\n\n// const o = new Dispatch()\n//\n// o.on('post', (...args: Array<any>) => {\n//     console.log(1, args)\n// })\n//\n// const fn = (...args: Array<any>) => {\n//     console.log(2, args)\n// }\n// o.once('post', fn)\n// // o.off('post', fn)\n// o.emit('post', 1,false,'小满', { name: '小满' })\n// o.emit('post', 1,false,'小满', { name: '小满' })\n\n/*\n* ts进阶proxy reflect\n* */\n\ntype Person = {\n    name: string,\n    age: number,\n    text: string\n}\n\n\nconst proxy = (object: any, key:any)=>{\n    return new Proxy(object, {\n        get(target: any, prop: string | symbol, receiver: any): any {\n            console.log('===>get',prop)\n            return Reflect.get(target,prop,receiver)\n            // return target[prop]\n        },\n        set(target: any, prop: string | symbol, newValue: any, receiver: any): boolean {\n            console.log('===>set',prop)\n            return Reflect.set(target,prop,newValue,receiver)\n            // return target[prop] = newValue\n        }\n    })\n}\n\nexport const logAccess = (object:Person, key: keyof Person):Person => {\n    return proxy(object, key)\n}\n\n\n\n// let man:Person = logAccess({\n//     name: '小满',\n//     age: 22,\n//     text: '哈哈哈'\n// }, 'age')\n// console.log(man)\n// console.log(man.name)\n// man.age = 30\n// console.log(man)\n\n\n/*\n* ts进阶Partial & Pick\n* */\ntype Readonly2<T> = {\n    readonly [P in keyof T]?: T[P];\n};\n\ntype Record2<K extends keyof any, T> = {\n    [P in K]?: T;\n};\n\ntype p = Partial<Person>\ntype p2 = Pick<Person, 'age'|'name'>\ntype p3 = Readonly<Person>\ntype p4 = Readonly2<Person>\ntype key = \"A\"|\"B\"\ntype p5 = Record2<key,Person>\n\nlet obj:p5 = {\n    A: { name: '',age:0,text:'' },\n    B: { name: '',age:0,text:'' },\n}\n\n/*\n* ts进阶用法 infer关键字\n* */\n\n// 定义一个类型 如果是数组类型 就返回 数组元素的类型 否则 就传入什么类型 就返回什么类型\n\n// type TYPE<T> = T extends Array<any> ? T[number] : T\ntype TYPE<T> = T extends Array<infer U> ? U : T\ntype T = [string, number]\ntype uni = TYPE<T>\ntype A = TYPE<Array<string|number>>\ntype A1 = TYPE<(string|number)[]>\ntype B = TYPE<boolean>\nlet a:A = 12\nlet b:B = false\n\n\n/*\n* ts进阶用法 infer提取元素的妙用\n* */\n\ntype Arr = ['a','b','c']\ntype First<T extends any[]> = T extends [infer A, ...any[]] ? A : []\ntype Last<T extends any[]> = T extends [...any[], infer Last,] ? Last : [] //  无效\ntype Pop<T extends any[]> = T extends [...infer Reset, unknown] ? Reset : [] // 无效\ntype Shift<T extends any[]> = T extends [unknown, ...infer Reset] ? Reset : []\ntype a = First<Arr>\ntype b = Last<Arr>\ntype c = Pop<Arr>\ntype d = Shift<Arr>\n\n/*\n* ts进阶用法 infer递归\n* */\ntype Arra = [1,2,3,4]\ntype ReverArr<T extends any[]> = T extends [infer First, ...infer rest] ? [...ReverArr<rest>, First] : T\n\ntype Arrb = ReverArr<Arra>\n\n"],"names":[],"mappings":";;;;;;;;IAAA;;IAEI;UA4BS,QAAQ,CAAA;IAEjB,IAAA,WAAA,GAAA;IACI,QAAA,IAAI,CAAC,IAAI,GAAG,EAAE,CAAA;SACjB;QACD,EAAE,CAAC,IAAW,EAAC,EAAW,EAAA;YACtB,MAAM,SAAS,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,CAAA;IACvC,QAAA,SAAS,CAAC,IAAI,CAAC,EAAE,CAAC,CAAA;IAClB,QAAA,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,SAAS,CAAA;SAC9B;IACD,IAAA,IAAI,CAAC,IAAW,EAAE,GAAG,IAAe,EAAA;YAChC,IAAI,SAAS,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;IAC/B,QAAA,IAAG,SAAS,EAAC;IACT,YAAA,SAAS,CAAC,OAAO,CAAC,EAAE,IAAE;IAClB,gBAAA,EAAE,CAAC,GAAG,IAAI,CAAC,CAAA;IACf,aAAC,CAAC,CAAA;IACL,SAAA;SACJ;QACD,GAAG,CAAC,IAAY,EAAE,EAAW,EAAA;YACzB,IAAI,SAAS,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;YAC/B,IAAG,SAAS,IAAI,EAAE,EAAC;IACf,YAAA,IAAI,KAAK,GAAG,SAAS,CAAC,SAAS,CAAC,GAAG,IAAI,GAAG,KAAK,EAAE,CAAC,CAAA;IAClD,YAAA,SAAS,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC,CAAC,CAAA;IAC7B,SAAA;SACJ;QACD,IAAI,CAAC,IAAW,EAAC,EAAW,EAAA;IACxB,QAAA,IAAI,EAAE,GAAG,CAAC,GAAG,IAAgB,KAAG;IAC5B,YAAA,EAAE,CAAC,GAAG,IAAI,CAAC,CAAA;IACX,YAAA,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,EAAE,CAAC,CAAA;IACtB,SAAC,CAAA;IAED,QAAA,IAAI,CAAC,EAAE,CAAC,IAAI,EAAE,EAAE,CAAC,CAAA;SACpB;IACJ,CAAA;IA4BD,MAAM,KAAK,GAAG,CAAC,MAAW,EAAE,GAAO,KAAG;IAClC,IAAA,OAAO,IAAI,KAAK,CAAC,MAAM,EAAE;IACrB,QAAA,GAAG,CAAC,MAAW,EAAE,IAAqB,EAAE,QAAa,EAAA;IACjD,YAAA,OAAO,CAAC,GAAG,CAAC,SAAS,EAAC,IAAI,CAAC,CAAA;gBAC3B,OAAO,OAAO,CAAC,GAAG,CAAC,MAAM,EAAC,IAAI,EAAC,QAAQ,CAAC,CAAA;;aAE3C;IACD,QAAA,GAAG,CAAC,MAAW,EAAE,IAAqB,EAAE,QAAa,EAAE,QAAa,EAAA;IAChE,YAAA,OAAO,CAAC,GAAG,CAAC,SAAS,EAAC,IAAI,CAAC,CAAA;IAC3B,YAAA,OAAO,OAAO,CAAC,GAAG,CAAC,MAAM,EAAC,IAAI,EAAC,QAAQ,EAAC,QAAQ,CAAC,CAAA;;aAEpD;IACJ,KAAA,CAAC,CAAA;IACN,CAAC,CAAA;UAEY,SAAS,GAAG,CAAC,MAAa,EAAE,GAAiB,KAAW;IACjE,IAAA,OAAO,KAAK,CAAC,MAAW,CAAC,CAAA;IAC7B;;;;;;;;;"}